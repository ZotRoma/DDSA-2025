<h1>Описание что было сделано в лабе</h1>
<h2>Немного теории</h2>
<p>Сокеты Беркли (Berkeley Sockets) — это интерфейс программирования приложений (API), разработанный в Университете Калифорнии в Беркли в 1980-х годах для работы с сетями в операционных системах типа Unix. Этот интерфейс стал стандартом для сетевого взаимодействия и используется в большинстве современных систем, включая Linux, macOS и Windows (в виде Winsock).</p>
<p>Сокеты Беркли предоставляют набор функций и структур данных для:</p>

- Установления соединений между устройствами в сети.
- Передачи данных (например, отправки и получения сообщений).
- Управления сетевыми протоколами (TCP, UDP и др.).
<p>В контексте лабораторной работы сокеты Беркли используются для передачи данных изображения между клиентом и сервером через сеть.</p>

<h2>Теперь по лабе</h2>

Чтобы запустить лабораторную работу нужно 2 компьютера подключенных в локальной сети (WIFI).

Должен быть установлен python.

И библиотеки pillow opencv-python scikit-image numpy.

<p><br>socket.socket(socket.AF_INET, socket.SOCK_STREAM)
<br>создаем новый объект сокета — для сетевого взаимодействия</p>

- AF_INET - для IPv4
- SOCK_STREAM - для TCP

<h3>Клиент</h3>
<p>client.connect((host, port)) - инициируем соединение с сервером</p>
<p>в моем случае я использовал
<br>host - 192.168.1.31 (в локальной сети. найти: cmd -> ipconfig -> Адаптер беспроводной локальной сети Беспроводная сеть -> IPv4-адрес)    
<br>port - 12345 (это уникальный идентификатор процесса на сервере)</p>

<p>Далее используя cv2.imread считываем изображение
<br>потом добавляем импульсный шум к изображению методом add_impulse_noise()
<br>дальше методом sendall() - отправляем данные на сервер (битовый массив - сначала размеры, потом картинку)
<br>&nbsp; - sendall() - передает все данные (ждеть, пока все данные не будут отправлены, прежде чем вернуть управление программе)
<br>client.close() - закрывает подлючение</p>

<h3>Сервер</h3>
<p>server.bind() - привязывает сокет к конкретному адресу и порту на сервере, чтобы он мог "слушать" входящие подключения
<br>&nbsp; - 0.0.0.0' - означает "слушать все доступные сетевые интерфейсы"
<br>server.listen(1) - переводит сокет в режим "прослушивания", чтобы он начал принимать входящие подключения от клиентов
<br>&nbsp; - значение 1 означает, что сервер будет обрабатывать только одно подключение за раз
<br>server.accept() - метод, который ожидает входящее подключение от клиента
<br>&nbsp; - conn - объект сокета, который будет использоваться для общения с конкретным клиентом
<br>&nbsp; - addr - адрес клиента в виде кортежа
<br>recv() - метод принимает данные из сокета conn
<br>np.frombuffer(data, dtype=np.uint8).reshape((height, width,channels)) - преобразуем байты изображения в одномерный массив чисел, а дальше переделываем одномерный массив в трехмерный (для изображения)
<br>cv2.medianBlur(image, kernel_size) - применяем медианный фильтр из библиотеки cv2
<br>psnr(original, distorted)
<br>PSNR — это метрика, которая измеряет качество изображения в децибелах (дБ). Чем выше значение PSNR, тем лучше качество изображения.</p>

<h2>Результат</h2>
<h3>Сервер</h3>

Сначала запускаем сервер. Чтобы запустить - python server.py
Потом запускаем клиента. Чтобы запустить - python client.py
Важно чтобы они были в одной локальной сети.

Вывод в консоль:

```
Ожидание подключения...
Подключено: ('192.168.1.47', 63128)
Изобажение сохранено как received_noisy_image.png
Фильтр применен, изображение сохранено как restored_image.png
Изображение обработано и сохранено.
PSNR зашумленного изображения: 17.56 dB
PSNR восстановленного изображения: 31.77 dB
```

Полученное изображение:

![alt text](./server/received_noisy_image.png)

Изображение после фильтра:

![alt text](./server/restored_image.png)

<h3>Клиент</h3>

Вывод в консоль:

```
Изображение отправлено.
```

Оригинальное изображение:

![alt text](./client/image.png)

Изображение после фильтра:

![alt text](./client/noisy_image.png)